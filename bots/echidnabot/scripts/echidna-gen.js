#!/usr/bin/env -S deno run --allow-read --allow-write
// SPDX-License-Identifier: PMPL-1.0
// Echidna Test Property Generator
// Generates Echidna test contracts from Solidity source files
//
// Usage: deno run --allow-read --allow-write scripts/echidna-gen.js <contract.sol>

const SPDX_HEADER = `// SPDX-License-Identifier: PMPL-1.0
// Generated by echidnabot - Echidna Test Generator
// https://github.com/hyperpolymath/echidnabot
`;

/**
 * Parse a Solidity contract and extract key information
 * @param {string} source - Solidity source code
 * @returns {object} Parsed contract info
 */
function parseContract(source) {
  const contractMatch = source.match(/contract\s+(\w+)(?:\s+is\s+([^{]+))?\s*\{/);
  if (!contractMatch) {
    throw new Error("No contract found in source file");
  }

  const name = contractMatch[1];
  const inheritance = contractMatch[2]?.split(",").map((s) => s.trim()) || [];

  // Extract state variables
  const stateVars = [];
  const stateVarRegex =
    /^\s*(uint256|uint128|uint64|uint32|uint16|uint8|int256|int128|int64|int32|int16|int8|address|bool|string|bytes32|bytes)\s+(public\s+|private\s+|internal\s+)?(\w+)/gm;
  let match;
  while ((match = stateVarRegex.exec(source)) !== null) {
    stateVars.push({
      type: match[1],
      visibility: match[2]?.trim() || "internal",
      name: match[3],
    });
  }

  // Extract mappings
  const mappings = [];
  const mappingRegex =
    /mapping\s*\(\s*(\w+)\s*=>\s*(\w+)\s*\)\s+(public\s+|private\s+|internal\s+)?(\w+)/g;
  while ((match = mappingRegex.exec(source)) !== null) {
    mappings.push({
      keyType: match[1],
      valueType: match[2],
      visibility: match[3]?.trim() || "internal",
      name: match[4],
    });
  }

  // Extract functions
  const functions = [];
  const funcRegex =
    /function\s+(\w+)\s*\(([^)]*)\)\s+(public|external|internal|private)?[^{]*\{/g;
  while ((match = funcRegex.exec(source)) !== null) {
    functions.push({
      name: match[1],
      params: match[2],
      visibility: match[3] || "public",
    });
  }

  // Extract pragma version
  const pragmaMatch = source.match(/pragma\s+solidity\s+([^;]+);/);
  const pragmaVersion = pragmaMatch ? pragmaMatch[1] : "^0.8.19";

  return {
    name,
    inheritance,
    stateVars,
    mappings,
    functions,
    pragmaVersion,
  };
}

/**
 * Generate invariant properties based on contract analysis
 * @param {object} contract - Parsed contract info
 * @returns {string[]} Array of invariant function strings
 */
function generateInvariants(contract) {
  const invariants = [];

  // Generate balance invariants for uint state variables
  for (const v of contract.stateVars) {
    if (v.type.startsWith("uint")) {
      invariants.push(`
    /// @notice ${v.name} should maintain valid bounds
    function echidna_${v.name}_valid() public view returns (bool) {
        return ${v.name} >= 0;
    }`);
    }

    if (v.type === "address" && v.name !== "owner") {
      invariants.push(`
    /// @notice ${v.name} address validation
    function echidna_${v.name}_not_zero() public view returns (bool) {
        // Allow zero address if intentionally set
        return true;
    }`);
    }
  }

  // Generate mapping invariants
  for (const m of contract.mappings) {
    if (m.valueType.startsWith("uint")) {
      invariants.push(`
    /// @notice Mapping ${m.name} values should be valid
    function echidna_${m.name}_valid(${m.keyType} key) public view returns (bool) {
        return ${m.name}[key] >= 0;
    }`);
    }
  }

  // Check for common patterns
  const hasOwner = contract.stateVars.some((v) => v.name === "owner");
  if (hasOwner) {
    invariants.push(`
    /// @notice Owner should always be set after construction
    function echidna_owner_set() public view returns (bool) {
        return owner != address(0);
    }`);
  }

  const hasTotalSupply = contract.stateVars.some(
    (v) => v.name === "totalSupply"
  );
  const hasBalanceOf = contract.mappings.some((m) => m.name === "balanceOf");
  if (hasTotalSupply && hasBalanceOf) {
    invariants.push(`
    /// @notice User balance should never exceed total supply
    function echidna_balance_bounded() public view returns (bool) {
        return balanceOf[msg.sender] <= totalSupply;
    }`);
  }

  const hasPaused = contract.stateVars.some((v) => v.name === "paused");
  if (hasPaused) {
    invariants.push(`
    /// @notice Paused state consistency check
    function echidna_pause_consistent() public view returns (bool) {
        return paused == true || paused == false; // Always true, but demonstrates state tracking
    }`);
  }

  return invariants;
}

/**
 * Generate assertion-based test functions
 * @param {object} contract - Parsed contract info
 * @returns {string[]} Array of test function strings
 */
function generateAssertionTests(contract) {
  const tests = [];

  // Generate tests for transfer-like functions
  const transferFuncs = contract.functions.filter(
    (f) =>
      f.name.toLowerCase().includes("transfer") ||
      f.name.toLowerCase().includes("send")
  );

  for (const func of transferFuncs) {
    tests.push(`
    /// @notice Test ${func.name} balance accounting
    function test_${func.name}_accounting(address to, uint256 amount) public {
        if (to == address(0) || to == msg.sender) return;
        if (amount == 0 || amount > balanceOf[msg.sender]) return;

        uint256 senderBefore = balanceOf[msg.sender];
        uint256 receiverBefore = balanceOf[to];

        try this.${func.name}(to, amount) {
            assert(balanceOf[msg.sender] == senderBefore - amount);
            assert(balanceOf[to] == receiverBefore + amount);
        } catch {
            // Transfer failed, balances should be unchanged
            assert(balanceOf[msg.sender] == senderBefore);
            assert(balanceOf[to] == receiverBefore);
        }
    }`);
  }

  // Generate tests for mint-like functions
  const mintFuncs = contract.functions.filter((f) =>
    f.name.toLowerCase().includes("mint")
  );

  for (const func of mintFuncs) {
    tests.push(`
    /// @notice Test ${func.name} supply increase
    function test_${func.name}_supply(address to, uint256 amount) public {
        if (to == address(0) || amount == 0) return;

        uint256 supplyBefore = totalSupply;

        try this.${func.name}(to, amount) {
            assert(totalSupply == supplyBefore + amount);
        } catch {
            assert(totalSupply == supplyBefore);
        }
    }`);
  }

  // Generate tests for burn-like functions
  const burnFuncs = contract.functions.filter((f) =>
    f.name.toLowerCase().includes("burn")
  );

  for (const func of burnFuncs) {
    tests.push(`
    /// @notice Test ${func.name} supply decrease
    function test_${func.name}_supply(uint256 amount) public {
        if (amount == 0 || amount > balanceOf[msg.sender]) return;

        uint256 supplyBefore = totalSupply;

        try this.${func.name}(amount) {
            assert(totalSupply == supplyBefore - amount);
        } catch {
            assert(totalSupply == supplyBefore);
        }
    }`);
  }

  return tests;
}

/**
 * Generate the complete Echidna test contract
 * @param {object} contract - Parsed contract info
 * @param {string} importPath - Relative import path
 * @returns {string} Complete test contract source
 */
function generateTestContract(contract, importPath) {
  const invariants = generateInvariants(contract);
  const assertionTests = generateAssertionTests(contract);

  const testContractName = `${contract.name}EchidnaTest`;

  return `${SPDX_HEADER}
pragma solidity ${contract.pragmaVersion};

import "${importPath}";

/// @title ${testContractName} - Auto-generated Echidna fuzz testing contract
/// @notice Property-based tests for ${contract.name}
/// @dev Generated invariants and assertion tests for fuzzing
contract ${testContractName} is ${contract.name} {
    // ========== TEST CONFIGURATION ==========

    address private constant ECHIDNA_SENDER = address(0x10000);
    address private constant ECHIDNA_RECEIVER = address(0x20000);

    // ========== CONSTRUCTOR ==========

    constructor() ${contract.name}(${contract.name === "Token" ? "1_000_000 * 10 ** 18" : ""}) {
        // Initial test setup
    }

    // ========== INVARIANT PROPERTIES ==========
    // These must ALWAYS return true. Echidna tries to break them.
${invariants.join("\n")}

    // ========== ASSERTION-BASED TESTS ==========
    // These use assert() to verify specific behaviors
${assertionTests.join("\n")}
}
`;
}

/**
 * Main CLI handler
 */
async function main() {
  const args = Deno.args;

  if (args.length < 1) {
    console.log(`
Echidna Test Generator - Generate fuzz tests for Solidity contracts

Usage:
  deno run --allow-read --allow-write scripts/echidna-gen.js <contract.sol> [output.sol]

Arguments:
  <contract.sol>  Path to the Solidity contract to analyze
  [output.sol]    Optional output path (default: <contract>EchidnaTest.sol)

Examples:
  deno run --allow-read --allow-write scripts/echidna-gen.js contracts/Token.sol
  deno run --allow-read --allow-write scripts/echidna-gen.js contracts/Vault.sol contracts/VaultTest.sol
`);
    Deno.exit(1);
  }

  const inputPath = args[0];
  const source = await Deno.readTextFile(inputPath);

  console.log(`Analyzing ${inputPath}...`);

  const contract = parseContract(source);

  console.log(`Found contract: ${contract.name}`);
  console.log(`  State variables: ${contract.stateVars.length}`);
  console.log(`  Mappings: ${contract.mappings.length}`);
  console.log(`  Functions: ${contract.functions.length}`);

  // Calculate import path
  const inputDir = inputPath.split("/").slice(0, -1).join("/");
  const inputFile = inputPath.split("/").pop();
  const importPath = `./${inputFile}`;

  // Generate test contract
  const testSource = generateTestContract(contract, importPath);

  // Determine output path
  const outputPath = args[1] || inputPath.replace(".sol", "EchidnaTest.sol");

  await Deno.writeTextFile(outputPath, testSource);

  console.log(`\nGenerated Echidna test contract: ${outputPath}`);
  console.log(`
Next steps:
  1. Review and customize the generated tests
  2. Run Echidna:
     echidna ${outputPath} --contract ${contract.name}EchidnaTest --config echidna/echidna-config.yaml
`);
}

main().catch((err) => {
  console.error(`Error: ${err.message}`);
  Deno.exit(1);
});
