// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

let tokenCache = {};

function pemToArrayBuffer(pem) {
  let pemContents = pem.replace(/-----BEGIN (?:RSA )?PRIVATE KEY-----/g, "").replace(/-----END (?:RSA )?PRIVATE KEY-----/g, "").replace(/\\s/g, "");
  let binaryStr = globalThis.atob(pemContents);
  let len = binaryStr.length;
  let bytes = new Uint8Array(len);
  for (let i = 0; i < len; ++i) {
    let charCode = binaryStr.charCodeAt(i) | 0;
    bytes[i] = charCode;
  }
  return bytes.buffer;
}

function base64UrlEncode(data) {
  let len = data.length;
  let binaryStr = "";
  for (let i = 0; i < len; ++i) {
    let byte = data[i];
    binaryStr = binaryStr + String.fromCharCode(byte);
  }
  return globalThis.btoa(binaryStr).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function base64UrlEncodeString(str) {
  return globalThis.btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

async function generateJWT(appId, privateKeyPem) {
  let nowSeconds = Date.now() / 1000.0;
  let header = Js_dict.fromArray([
    [
      "alg",
      "RS256"
    ],
    [
      "typ",
      "JWT"
    ]
  ]);
  let headerB64 = base64UrlEncodeString(JSON.stringify(header));
  let payload = Js_dict.fromArray([
    [
      "iss",
      appId
    ],
    [
      "iat",
      nowSeconds - 60.0
    ],
    [
      "exp",
      nowSeconds + 600.0
    ]
  ]);
  let payloadB64 = base64UrlEncodeString(JSON.stringify(payload));
  let message = headerB64 + `.` + payloadB64;
  try {
    let keyBuffer = pemToArrayBuffer(privateKeyPem);
    let encoder = new (globalThis.TextEncoder)();
    let key = await globalThis.crypto.subtle.importKey("pkcs8", keyBuffer, {
      name: "RSASSA-PKCS1-v1_5",
      hash: "SHA-256"
    }, false, ["sign"]);
    let messageBytes = encoder.encode(message);
    let signatureBuffer = await globalThis.crypto.subtle.sign({
      name: "RSASSA-PKCS1-v1_5"
    }, key, messageBytes);
    let signatureBytes = new (globalThis.Uint8Array)(signatureBuffer);
    let signatureB64 = base64UrlEncode(signatureBytes);
    return {
      TAG: "Ok",
      _0: message + `.` + signatureB64
    };
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    let jsExn = Stdlib_Exn.asJsExn(exn);
    let msg = jsExn !== undefined ? Belt_Option.getWithDefault(Primitive_option.valFromOption(jsExn).message, "Unknown error") : "Unknown error";
    return {
      TAG: "Error",
      _0: `Failed to generate JWT: ` + msg
    };
  }
}

async function getInstallationToken(jwt, installationId) {
  let cacheKey = String(installationId);
  let cached = Js_dict.get(tokenCache, cacheKey);
  if (cached !== undefined && cached.expiresAt > Date.now() + 60000.0) {
    return {
      TAG: "Ok",
      _0: cached
    };
  }
  try {
    let response = await globalThis.fetch(`https://api.github.com/app/installations/` + cacheKey + `/access_tokens`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ` + jwt,
        Accept: "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "User-Agent": "oikos-bot"
      }
    });
    if (response.ok) {
      let json = await response.json();
      let obj = Js_json.decodeObject(json);
      if (obj === undefined) {
        return {
          TAG: "Error",
          _0: "Invalid JSON response"
        };
      }
      let t = Js_dict.get(obj, "token");
      let token = t !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(t), "") : "";
      let e = Js_dict.get(obj, "expires_at");
      let expiresAtStr = e !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(e), "") : "";
      if (token === "") {
        return {
          TAG: "Error",
          _0: "No token in response"
        };
      }
      let expiresAtDate = new Date(expiresAtStr);
      let expiresAt = expiresAtDate.getTime();
      let installToken = {
        token: token,
        expiresAt: expiresAt
      };
      tokenCache[cacheKey] = installToken;
      return {
        TAG: "Ok",
        _0: installToken
      };
    }
    let status = response.status;
    let body = await response.text();
    return {
      TAG: "Error",
      _0: `GitHub API error ` + String(status) + `: ` + body
    };
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    let jsExn = Stdlib_Exn.asJsExn(exn);
    let msg = jsExn !== undefined ? Belt_Option.getWithDefault(Primitive_option.valFromOption(jsExn).message, "Unknown error") : "Unknown error";
    return {
      TAG: "Error",
      _0: `Failed to get installation token: ` + msg
    };
  }
}

function extractInstallationId(payload) {
  let obj = Js_json.decodeObject(payload);
  if (obj === undefined) {
    return;
  }
  let inst = Js_dict.get(obj, "installation");
  if (inst === undefined) {
    return;
  }
  let instObj = Js_json.decodeObject(inst);
  if (instObj === undefined) {
    return;
  }
  let id = Js_dict.get(instObj, "id");
  if (id === undefined) {
    return;
  }
  let num = Js_json.decodeNumber(id);
  if (num !== undefined) {
    return num | 0;
  }
}

async function getAuthToken(config, payload) {
  let match = config.githubAppId;
  let match$1 = config.githubPrivateKey;
  if (match === undefined) {
    return {
      TAG: "Error",
      _0: "GitHub App credentials not configured"
    };
  }
  if (match$1 === undefined) {
    return {
      TAG: "Error",
      _0: "GitHub App credentials not configured"
    };
  }
  let installationId = extractInstallationId(payload);
  if (installationId === undefined) {
    return {
      TAG: "Error",
      _0: "No installation ID in payload"
    };
  }
  let jwtResult = await generateJWT(match, match$1);
  if (jwtResult.TAG !== "Ok") {
    return {
      TAG: "Error",
      _0: jwtResult._0
    };
  }
  let tokenResult = await getInstallationToken(jwtResult._0, installationId);
  if (tokenResult.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: tokenResult._0.token
    };
  } else {
    return {
      TAG: "Error",
      _0: tokenResult._0
    };
  }
}

export {
  tokenCache,
  pemToArrayBuffer,
  base64UrlEncode,
  base64UrlEncodeString,
  generateJWT,
  getInstallationToken,
  extractInstallationId,
  getAuthToken,
}
/* No side effect */
