// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "@rescript/runtime/lib/es6/Belt_Int.js";
import * as ServerTea from "./tea/ServerTea.res.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";

function modeFromString(str) {
  switch (str) {
    case "consultant" :
      return "Consultant";
    case "regulator" :
      return "Regulator";
    default:
      return "Advisor";
  }
}

function init(flags) {
  let model_mode = modeFromString(flags.mode);
  let model_port = flags.port;
  let model_webhookSecret = flags.webhookSecret;
  let model_appId = flags.appId;
  let model_privateKeyPath = flags.privateKeyPath;
  let model_pendingAnalyses = [];
  let model_startTime = Date.now();
  let model = {
    mode: model_mode,
    port: model_port,
    webhookSecret: model_webhookSecret,
    appId: model_appId,
    privateKeyPath: model_privateKeyPath,
    pendingAnalyses: model_pendingAnalyses,
    totalProcessed: 0,
    startTime: model_startTime,
    healthy: true
  };
  console.log(`ðŸ›ï¸ Oikos Bot starting...`);
  console.log(`   Mode: ` + flags.mode);
  console.log(`   Port: ` + String(flags.port));
  return [
    model,
    ServerTea.Cmd.none
  ];
}

function update(msg, model) {
  if (typeof msg !== "object") {
    switch (msg) {
      case "HealthCheck" :
        console.log(`ðŸ’š Health check - processed: ` + String(model.totalProcessed));
        return [
          model,
          ServerTea.Cmd.none
        ];
      case "Tick" :
        let now = Date.now();
        let oneHour = 60.0 * 60.0 * 1000.0;
        let pendingAnalyses = model.pendingAnalyses.filter(a => now - a.createdAt < oneHour);
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: pendingAnalyses,
            totalProcessed: model.totalProcessed,
            startTime: model.startTime,
            healthy: model.healthy
          },
          ServerTea.Cmd.none
        ];
      case "Shutdown" :
        console.log(`ðŸ‘‹ Shutting down...`);
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: model.pendingAnalyses,
            totalProcessed: model.totalProcessed,
            startTime: model.startTime,
            healthy: false
          },
          ServerTea.Cmd.none
        ];
    }
  } else {
    switch (msg.TAG) {
      case "WebhookReceived" :
        let payload = msg._1;
        let source = msg._0;
        let sourceStr;
        sourceStr = source === "GitHub" ? "GitHub" : "GitLab";
        console.log(`ðŸ“¨ Webhook received from ` + sourceStr);
        return [
          model,
          ServerTea.Cmd.perform(async () => payload, p => ({
            TAG: "WebhookVerified",
            _0: source,
            _1: p
          }))
        ];
      case "WebhookVerified" :
        console.log(`âœ“ Webhook verified`);
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: model.pendingAnalyses,
            totalProcessed: model.totalProcessed + 1 | 0,
            startTime: model.startTime,
            healthy: model.healthy
          },
          ServerTea.Cmd.none
        ];
      case "WebhookRejected" :
        console.error(`âœ— Webhook rejected: ` + msg._0);
        return [
          model,
          ServerTea.Cmd.none
        ];
      case "AnalysisRequested" :
        let prNumber = msg._2;
        let repo = msg._1;
        console.log(`ðŸ” Analysis requested: ` + repo + `#` + String(prNumber));
        let analysis_id = msg._0;
        let analysis_createdAt = Date.now();
        let analysis = {
          id: analysis_id,
          repo: repo,
          prNumber: prNumber,
          status: "Pending",
          createdAt: analysis_createdAt
        };
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: model.pendingAnalyses.concat([analysis]),
            totalProcessed: model.totalProcessed,
            startTime: model.startTime,
            healthy: model.healthy
          },
          ServerTea.Cmd.none
        ];
      case "AnalysisStarted" :
        let id = msg._0;
        let pendingAnalyses$1 = model.pendingAnalyses.map(a => {
          if (a.id === id) {
            return {
              id: a.id,
              repo: a.repo,
              prNumber: a.prNumber,
              status: "InProgress",
              createdAt: a.createdAt
            };
          } else {
            return a;
          }
        });
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: pendingAnalyses$1,
            totalProcessed: model.totalProcessed,
            startTime: model.startTime,
            healthy: model.healthy
          },
          ServerTea.Cmd.none
        ];
      case "AnalysisCompleted" :
        let result = msg._1;
        let id$1 = msg._0;
        console.log(`âœ“ Analysis completed: ` + id$1);
        let pendingAnalyses$2 = model.pendingAnalyses.map(a => {
          if (a.id === id$1) {
            return {
              id: a.id,
              repo: a.repo,
              prNumber: a.prNumber,
              status: {
                TAG: "Completed",
                _0: result
              },
              createdAt: a.createdAt
            };
          } else {
            return a;
          }
        });
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: pendingAnalyses$2,
            totalProcessed: model.totalProcessed,
            startTime: model.startTime,
            healthy: model.healthy
          },
          ServerTea.Cmd.none
        ];
      case "AnalysisFailed" :
        let error = msg._1;
        let id$2 = msg._0;
        console.error(`âœ— Analysis failed: ` + id$2 + ` - ` + error);
        let pendingAnalyses$3 = model.pendingAnalyses.map(a => {
          if (a.id === id$2) {
            return {
              id: a.id,
              repo: a.repo,
              prNumber: a.prNumber,
              status: {
                TAG: "Failed",
                _0: error
              },
              createdAt: a.createdAt
            };
          } else {
            return a;
          }
        });
        return [
          {
            mode: model.mode,
            port: model.port,
            webhookSecret: model.webhookSecret,
            appId: model.appId,
            privateKeyPath: model.privateKeyPath,
            pendingAnalyses: pendingAnalyses$3,
            totalProcessed: model.totalProcessed,
            startTime: model.startTime,
            healthy: model.healthy
          },
          ServerTea.Cmd.none
        ];
      case "CommentPosted" :
        console.log(`ðŸ’¬ Comment posted to ` + msg._0 + `#` + String(msg._1));
        return [
          model,
          ServerTea.Cmd.none
        ];
      case "CommentFailed" :
        console.error(`âœ— Failed to post comment to ` + msg._0 + `: ` + msg._1);
        return [
          model,
          ServerTea.Cmd.none
        ];
    }
  }
}

function subscriptions(model) {
  if (model.healthy) {
    return ServerTea.Sub.batch([
      ServerTea.Sub.httpServer(model.port, json => ({
        TAG: "WebhookReceived",
        _0: "GitHub",
        _1: json
      })),
      ServerTea.Sub.every(60000, () => "Tick")
    ]);
  } else {
    return ServerTea.Sub.none;
  }
}

function run() {
  let p = Deno.env.get("PORT");
  let port = p !== undefined ? Belt_Option.getWithDefault(Belt_Int.fromString(p), 3000) : 3000;
  let mode = Belt_Option.getWithDefault(Deno.env.get("BOT_MODE"), "advisor");
  let webhookSecret = Deno.env.get("GITHUB_WEBHOOK_SECRET");
  let appId = Deno.env.get("GITHUB_APP_ID");
  let privateKeyPath = Deno.env.get("GITHUB_PRIVATE_KEY_PATH");
  let flags = {
    port: port,
    mode: mode,
    webhookSecret: webhookSecret,
    appId: appId,
    privateKeyPath: privateKeyPath
  };
  return ServerTea.Runtime.make(init, update, subscriptions, flags);
}

run();

export {
  modeFromString,
  init,
  update,
  subscriptions,
  run,
}
/*  Not a pure module */
