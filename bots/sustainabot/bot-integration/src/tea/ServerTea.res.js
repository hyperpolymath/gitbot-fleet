// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function batch(cmds) {
  return {
    TAG: "Batch",
    _0: cmds
  };
}

function perform(task, toMsg) {
  return {
    TAG: "Perform",
    _0: async () => toMsg(await task())
  };
}

function attempt(task, toMsg) {
  return {
    TAG: "Perform",
    _0: async () => {
      try {
        return toMsg({
          TAG: "Ok",
          _0: await task()
        });
      } catch (raw_exn) {
        let exn = Primitive_exceptions.internalToException(raw_exn);
        return toMsg({
          TAG: "Error",
          _0: exn
        });
      }
    }
  };
}

function withDispatch(fn) {
  return {
    TAG: "PerformWithDispatch",
    _0: fn
  };
}

let Cmd = {
  none: "None",
  batch: batch,
  perform: perform,
  attempt: attempt,
  withDispatch: withDispatch
};

function batch$1(subs) {
  return {
    TAG: "Batch",
    _0: subs
  };
}

function httpServer(port, handler) {
  return {
    TAG: "HttpServer",
    _0: port,
    _1: handler
  };
}

function every(ms, toMsg) {
  return {
    TAG: "Interval",
    _0: ms,
    _1: toMsg
  };
}

let Sub = {
  none: "None",
  batch: batch$1,
  httpServer: httpServer,
  every: every
};

async function executeCmd(cmd, dispatch) {
  if (typeof cmd !== "object") {
    return;
  }
  switch (cmd.TAG) {
    case "Batch" :
      cmd._0.forEach(c => {
        executeCmd(c, dispatch);
      });
      return;
    case "Perform" :
      return dispatch(await cmd._0());
    case "PerformWithDispatch" :
      return await cmd._0(dispatch);
  }
}

function make(init, update, subscriptions, flags) {
  let match = init(flags);
  let state = {
    model: match[0],
    subscriptions: [],
    running: true,
    httpServer: undefined,
    intervals: []
  };
  let dispatch = msg => {
    if (!state.running) {
      return;
    }
    let match = update(msg, state.model);
    state.model = match[0];
    executeCmd(match[1], dispatch);
    updateSubscriptions();
  };
  let updateSubscriptions = () => {
    let newSubs = subscriptions(state.model);
    state.subscriptions = [newSubs];
  };
  let startSubscription = sub => {
    if (typeof sub !== "object") {
      return;
    }
    switch (sub.TAG) {
      case "Batch" :
        sub._0.forEach(startSubscription);
        return;
      case "HttpServer" :
        let handler = sub._1;
        let server = Deno.serve({
          port: sub._0
        }, async req => {
          let body = await req.text();
          let json;
          try {
            json = JSON.parse(body);
          } catch (exn) {
            json = undefined;
          }
          let msg = Belt_Option.flatMap(json, handler);
          if (msg !== undefined) {
            dispatch(Primitive_option.valFromOption(msg));
            return new (globalThis.Response)("OK", {
              status: 200
            });
          } else {
            return new (globalThis.Response)("Ignored", {
              status: 200
            });
          }
        });
        state.httpServer = Primitive_option.some(server);
        return;
      case "Interval" :
        let toMsg = sub._1;
        let id = setInterval(() => dispatch(toMsg()), sub._0);
        state.intervals = state.intervals.concat([id]);
        return;
    }
  };
  executeCmd(match[1], dispatch);
  let initialSubs = subscriptions(state.model);
  startSubscription(initialSubs);
  return {
    dispatch: dispatch,
    getModel: () => state.model,
    stop: () => {
      state.running = false;
      Belt_Option.forEach(state.httpServer, server => {
        server.shutdown();
      });
      state.intervals.forEach(prim => {
        clearInterval(prim);
      });
    }
  };
}

let Runtime = {
  executeCmd: executeCmd,
  make: make
};

export {
  Cmd,
  Sub,
  Runtime,
}
/* No side effect */
