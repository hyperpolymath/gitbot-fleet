// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Config from "./Config.res.js";
import * as Report from "./Report.res.js";
import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Webhook from "./Webhook.res.js";
import * as Analysis from "./Analysis.res.js";
import * as GitHubAPI from "./GitHubAPI.res.js";
import * as GitHubApp from "./GitHubApp.res.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function log(level, msg, data) {
  let timestamp = new Date().toISOString();
  let logObj = data !== undefined ? Js_dict.fromArray([
      [
        "timestamp",
        timestamp
      ],
      [
        "level",
        level
      ],
      [
        "message",
        msg
      ],
      [
        "data",
        data
      ]
    ]) : Js_dict.fromArray([
      [
        "timestamp",
        timestamp
      ],
      [
        "level",
        level
      ],
      [
        "message",
        msg
      ]
    ]);
  console.log(JSON.stringify(logObj));
}

function info(msg, data) {
  log("info", msg, data);
}

function error(msg, data) {
  log("error", msg, data);
}

function extractPRInfo(payload) {
  let obj = Js_json.decodeObject(payload);
  if (obj === undefined) {
    return [
      0,
      "",
      ""
    ];
  }
  let n = Js_dict.get(obj, "number");
  let prNumber;
  if (n !== undefined) {
    let num = Js_json.decodeNumber(n);
    prNumber = num !== undefined ? num | 0 : 0;
  } else {
    prNumber = 0;
  }
  let pr = Js_dict.get(obj, "pull_request");
  let match;
  if (pr !== undefined) {
    let prObj = Js_json.decodeObject(pr);
    if (prObj !== undefined) {
      let b = Js_dict.get(prObj, "base");
      let base;
      if (b !== undefined) {
        let baseObj = Js_json.decodeObject(b);
        if (baseObj !== undefined) {
          let s = Js_dict.get(baseObj, "sha");
          base = s !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s), "") : "";
        } else {
          base = "";
        }
      } else {
        base = "";
      }
      let h = Js_dict.get(prObj, "head");
      let head;
      if (h !== undefined) {
        let headObj = Js_json.decodeObject(h);
        if (headObj !== undefined) {
          let s$1 = Js_dict.get(headObj, "sha");
          head = s$1 !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s$1), "") : "";
        } else {
          head = "";
        }
      } else {
        head = "";
      }
      match = [
        base,
        head
      ];
    } else {
      match = [
        "",
        ""
      ];
    }
  } else {
    match = [
      "",
      ""
    ];
  }
  return [
    prNumber,
    match[0],
    match[1]
  ];
}

function extractMRInfo(payload) {
  let obj = Js_json.decodeObject(payload);
  if (obj === undefined) {
    return [
      0,
      "",
      ""
    ];
  }
  let attrs = Js_dict.get(obj, "object_attributes");
  if (attrs === undefined) {
    return [
      0,
      "",
      ""
    ];
  }
  let attrsObj = Js_json.decodeObject(attrs);
  if (attrsObj === undefined) {
    return [
      0,
      "",
      ""
    ];
  }
  let n = Js_dict.get(attrsObj, "iid");
  let mrIid;
  if (n !== undefined) {
    let num = Js_json.decodeNumber(n);
    mrIid = num !== undefined ? num | 0 : 0;
  } else {
    mrIid = 0;
  }
  let refs = Js_dict.get(attrsObj, "diff_refs");
  let baseSha;
  if (refs !== undefined) {
    let refsObj = Js_json.decodeObject(refs);
    if (refsObj !== undefined) {
      let s = Js_dict.get(refsObj, "base_sha");
      baseSha = s !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s), "") : "";
    } else {
      baseSha = "";
    }
  } else {
    baseSha = "";
  }
  let commit = Js_dict.get(attrsObj, "last_commit");
  let headSha;
  if (commit !== undefined) {
    let commitObj = Js_json.decodeObject(commit);
    if (commitObj !== undefined) {
      let s$1 = Js_dict.get(commitObj, "id");
      headSha = s$1 !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s$1), "") : "";
    } else {
      headSha = "";
    }
  } else {
    headSha = "";
  }
  return [
    mrIid,
    baseSha,
    headSha
  ];
}

function jsonResponse(data, statusOpt) {
  let status = statusOpt !== undefined ? statusOpt : 200;
  return new (globalThis.Response)(JSON.stringify(data), {
    status: status,
    headers: {
      "Content-Type": "application/json"
    }
  });
}

async function validateGitHubSignature(config, headers, body) {
  let secret = config.githubWebhookSecret;
  if (secret === undefined) {
    return;
  }
  let signature = Belt_Option.getWithDefault(Js_dict.get(headers, "x-hub-signature-256"), "");
  let valid = await Webhook.verifyGitHubSignature(body, signature, secret);
  if (!valid) {
    log("error", "Invalid GitHub webhook signature", undefined);
    return Primitive_option.some(new (globalThis.Response)(`{"error": "Invalid signature"}`, {
      status: 401
    }));
  }
}

async function handleGitHubWebhook(config, headers, body) {
  let signatureError = await validateGitHubSignature(config, headers, body);
  if (signatureError !== undefined) {
    return Primitive_option.valFromOption(signatureError);
  }
  let parseResult;
  try {
    parseResult = JSON.parse(body);
  } catch (exn) {
    parseResult = undefined;
  }
  if (parseResult === undefined) {
    return new (globalThis.Response)(`{"error": "Invalid JSON"}`, {
      status: 400
    });
  }
  let event = Webhook.parseGitHubEvent(headers, parseResult);
  if (event !== undefined) {
    log("info", `GitHub event: ` + event.eventType, Js_dict.fromArray([
      [
        "repo",
        event.repository.owner + `/` + event.repository.name
      ],
      [
        "action",
        Belt_Option.getWithDefault(event.action, "")
      ]
    ]));
    if (event.eventType === "pull_request") {
      let action = Belt_Option.getWithDefault(event.action, "");
      if (action === "opened" || action === "synchronize") {
        let match = extractPRInfo(parseResult);
        let prNumber = match[0];
        let analysisResult = await Analysis.analyzeDiff(config.analysisEndpoint, event.repository.url, match[1], match[2]);
        let comment;
        if (analysisResult.TAG === "Ok") {
          comment = Report.generatePRComment(analysisResult._0, config.mode);
        } else {
          log("error", `Analysis failed: ` + analysisResult._0, undefined);
          let analysis = Analysis.mockAnalysis();
          comment = Report.generatePRComment(analysis, config.mode);
        }
        let authResult = await GitHubApp.getAuthToken(config, parseResult);
        if (authResult.TAG === "Ok") {
          let postResult = await GitHubAPI.postPRComment(authResult._0, event.repository.owner, event.repository.name, prNumber, comment);
          if (postResult.TAG === "Ok") {
            log("info", `Posted PR comment`, Js_dict.fromArray([
              [
                "pr",
                prNumber
              ],
              [
                "commentId",
                postResult._0
              ]
            ]));
          } else {
            log("error", `Failed to post PR comment: ` + postResult._0, undefined);
          }
        } else {
          log("info", `GitHub App not configured, comment not posted: ` + authResult._0, comment);
        }
      }
    }
    return jsonResponse(Js_dict.fromArray([[
        "status",
        "processed"
      ]]), undefined);
  }
  log("error", "Failed to parse GitHub event", undefined);
  return new (globalThis.Response)(`{"error": "Invalid event"}`, {
    status: 400
  });
}

function validateGitLabToken(config, headers) {
  let secret = config.gitlabWebhookSecret;
  if (secret === undefined) {
    return;
  }
  let token = Belt_Option.getWithDefault(Js_dict.get(headers, "x-gitlab-token"), "");
  if (!Webhook.verifyGitLabToken(token, secret)) {
    log("error", "Invalid GitLab webhook token", undefined);
    return Primitive_option.some(new (globalThis.Response)(`{"error": "Invalid token"}`, {
      status: 401
    }));
  }
}

async function handleGitLabWebhook(config, headers, body) {
  let tokenError = validateGitLabToken(config, headers);
  if (tokenError !== undefined) {
    return Primitive_option.valFromOption(tokenError);
  }
  let parseResult;
  try {
    parseResult = JSON.parse(body);
  } catch (exn) {
    parseResult = undefined;
  }
  if (parseResult === undefined) {
    return new (globalThis.Response)(`{"error": "Invalid JSON"}`, {
      status: 400
    });
  }
  let event = Webhook.parseGitLabEvent(headers, parseResult);
  if (event !== undefined) {
    log("info", `GitLab event: ` + event.eventType, Js_dict.fromArray([[
        "repo",
        event.repository.owner + `/` + event.repository.name
      ]]));
    if (event.eventType === "Merge Request Hook") {
      let match = extractMRInfo(parseResult);
      let analysisResult = await Analysis.analyzeDiff(config.analysisEndpoint, event.repository.url, match[1], match[2]);
      if (analysisResult.TAG === "Ok") {
        let comment = Report.generatePRComment(analysisResult._0, config.mode);
        log("info", `Generated MR comment for MR !` + String(match[0]), comment);
      } else {
        log("error", `Analysis failed: ` + analysisResult._0, undefined);
        let analysis = Analysis.mockAnalysis();
        let comment$1 = Report.generatePRComment(analysis, config.mode);
        log("info", `Generated fallback MR comment`, comment$1);
      }
    }
    return jsonResponse(Js_dict.fromArray([[
        "status",
        "processed"
      ]]), undefined);
  }
  log("error", "Failed to parse GitLab event", undefined);
  return new (globalThis.Response)(`{"error": "Invalid event"}`, {
    status: 400
  });
}

function handler(config) {
  return async (req, _connInfo) => {
    let url = req.url;
    let method = req.method;
    let path = url.replace(/^https?:\/\/[^\/]+/, "");
    switch (method) {
      case "GET" :
        switch (path) {
          case "/health" :
            return jsonResponse(Js_dict.fromArray([
              [
                "status",
                "healthy"
              ],
              [
                "mode",
                Config.modeToString(config.mode)
              ]
            ]), undefined);
          case "/metrics" :
            return jsonResponse(Js_dict.fromArray([
              [
                "oikos_bot_requests_total",
                0.0
              ],
              [
                "oikos_bot_analyses_total",
                0.0
              ]
            ]), undefined);
          default:
            return new (globalThis.Response)("Not Found", {
              status: 404
            });
        }
      case "POST" :
        switch (path) {
          case "/webhooks/github" :
            let body = await req.text();
            let headers = req.headers;
            return await handleGitHubWebhook(config, headers, body);
          case "/webhooks/gitlab" :
            let body$1 = await req.text();
            let headers$1 = req.headers;
            return await handleGitLabWebhook(config, headers$1, body$1);
          default:
            return new (globalThis.Response)("Not Found", {
              status: 404
            });
        }
      default:
        return new (globalThis.Response)("Not Found", {
          status: 404
        });
    }
  };
}

function main() {
  let config = Config.load();
  if (config.TAG !== "Ok") {
    return log("error", `Failed to load config: ` + config._0, undefined);
  }
  let config$1 = config._0;
  log("info", `Starting Oikos Bot`, Js_dict.fromArray([
    [
      "port",
      config$1.port
    ],
    [
      "mode",
      Config.modeToString(config$1.mode)
    ]
  ]));
  Deno.serve({
    port: config$1.port,
    onListen: param => log("info", `Server listening on ` + param.hostname + `:` + String(param.port), undefined)
  }, handler(config$1));
}

main();

export {
  log,
  info,
  error,
  extractPRInfo,
  extractMRInfo,
  jsonResponse,
  validateGitHubSignature,
  handleGitHubWebhook,
  validateGitLabToken,
  handleGitLabWebhook,
  handler,
  main,
}
/*  Not a pure module */
